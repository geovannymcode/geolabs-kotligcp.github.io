{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Despliegue de una API REST con Kotlin en Google Cloud con PostgreSQL","text":""},{"location":"#introduccion","title":"Introducci\u00f3n","text":"<p>El desarrollo de aplicaciones modernas requiere herramientas robustas y eficientes para facilitar la creaci\u00f3n, el despliegue y el mantenimiento de APIs. Este taller te guiar\u00e1 en el proceso de crear y desplegar una API REST desde cero utilizando Kotlin y Spring Boot, con integraci\u00f3n a PostgreSQL como base de datos y despliegue en Google Cloud App Engine.</p> <p>Aprender\u00e1s a usar Spring Initializr para configurar un proyecto base de forma sencilla, seleccionar las dependencias clave, y desplegar la aplicaci\u00f3n en un entorno gestionado que asegura escalabilidad y disponibilidad.</p>"},{"location":"#requisitos-para-el-taller","title":"Requisitos para el taller","text":""},{"location":"#1-conocimientos-previos","title":"1. Conocimientos previos","text":"<p>Para aprovechar al m\u00e1ximo este taller, es recomendable contar con los siguientes conocimientos b\u00e1sicos:</p> <ul> <li>Concepto b\u00e1sico de APIs REST: C\u00f3mo funcionan y para qu\u00e9 se utilizan..</li> <li>Familiaridad con Kotlin o Java: Conocimientos b\u00e1sicos de sintaxis y programaci\u00f3n orientada a objetos.</li> <li>Conceptos b\u00e1sicos de bases de datos relacionales: C\u00f3mo funcionan las tablas, relaciones y consultas SQL.</li> </ul>"},{"location":"#2-herramientas-necesarias","title":"2. Herramientas necesarias:","text":"<p>Antes de iniciar el taller, aseg\u00farate de tener instaladas y configuradas las siguientes herramientas:</p>"},{"location":"#software","title":"Software","text":"<ul> <li>Java Development Kit (JDK) 21: Necesario para compilar y ejecutar la aplicaci\u00f3n.</li> <li>Google Cloud Platform (GCP): Una cuenta activa para trabajar con los servicios de Google Cloud.</li> <li>Spring Boot: Versi\u00f3n 3.2.x o superior para desarrollar la aplicaci\u00f3n.</li> <li>PostgreSQL 16: Puede estar instalado localmente o ejecutarse a trav\u00e9s de un contenedor Docker.</li> </ul>"},{"location":"#entorno-de-desarrollo","title":"Entorno de Desarrollo","text":"<ul> <li>IntelliJ IDEA (recomendado) Un IDE potente compatible con Kotlin y Gradle.</li> <li>Docker Desktop: UPara crear entornos de desarrollo consistentes y pruebas locales.</li> </ul>"},{"location":"#herramientas-de-google-cloud","title":"Herramientas de Google Cloud","text":"<ul> <li>Google Cloud SDK: Instalado y configurado para interactuar con servicios de GCP.</li> <li>gcloud CLI Tool: Para gestionar despliegues y recursos desde la terminal.</li> </ul>"},{"location":"#paso-a-paso-basado-en-spring-initializr","title":"Paso a paso basado en Spring Initializr","text":"<p>En este paso, configuraremos un proyecto base utilizando Spring Initializr, seleccionando las dependencias necesarias para nuestro proyecto de API REST con Kotlin y PostgreSQL. Sigue estas instrucciones para preparar tu entorno.</p> <p></p> <p> Figura # 1: Configuraci\u00f3n de Spring Initializr </p> <ol> <li> <p>Selecci\u00f3n del Proyecto y Lenguaje:</p> <ul> <li>Abre la p\u00e1gina de Spring Initializr</li> <li>Configura las siguientes opciones iniciales como se muestra en la Figura 1:<ul> <li>Project (1): Selecciona Gradle - Kotlin para aprovechar las ventajas del sistema de construcci\u00f3n Gradle y la sintaxis concisa de Kotlin.</li> <li>Language (2): Selecciona Kotlin como lenguaje principal.</li> <li>Spring Boot Version: Elige la versi\u00f3n m\u00e1s reciente estable (3.2.x o superior).</li> </ul> </li> </ul> </li> <li> <p>Configuraci\u00f3n de Metadatos del Proyecto:</p> <ul> <li>En la misma p\u00e1gina, completa los campos relacionados con los metadatos del proyecto. Consulta la Figura 1 para validar la configuraci\u00f3n:<ul> <li>Group: <code>com.geovannycode</code> (define el grupo base del paquete del proyecto).</li> <li>Artifact: <code>kotlin-gcp</code> (como nombre base del artefacto).</li> <li>Name: <code>kotlin-gcp</code> (nombre del proyecto).</li> <li>Description: <code>Demo project for Spring Boot</code> (puedes personalizarlo seg\u00fan el contexto).</li> <li>Package Name: Preconfigurado como <code>com.geovannycode</code>.</li> <li>Packaging (3): Selecciona Jar.</li> <li>Java Version: Selecciona 21 (\u00faltima versi\u00f3n compatible con Kotlin y Spring Boot).</li> </ul> </li> </ul> </li> <li> <p>Dependencias Importantes: Las dependencias son m\u00f3dulos o bibliotecas que agregan funcionalidades espec\u00edficas al proyecto. Cada una de las dependencias seleccionadas cumple un prop\u00f3sito esencial para construir nuestra API REST de manera eficiente. A continuaci\u00f3n, se explica cada una:</p> <ul> <li>Haz clic en el bot\u00f3n Add Dependencies y selecciona las dependencias necesarias como se muestra en la Figura 1 (4): <ul> <li>Spring Web<ul> <li>Prop\u00f3sito: Permite construir aplicaciones web y APIs RESTful utilizando el modelo MVC (Model-View-Controller) de Spring.</li> <li>Caracter\u00edsticas clave:<ul> <li>Facilita la creaci\u00f3n de controladores REST para manejar solicitudes HTTP (GET, POST, PUT, DELETE).</li> <li>Incluye un servidor embebido (por defecto Tomcat), lo que elimina la necesidad de configurar un servidor externo.</li> </ul> </li> </ul> </li> <li>Spring Data JPA<ul> <li>Prop\u00f3sito: Proporciona una forma sencilla y eficiente de interactuar con bases de datos relacionales utilizando JPA (Java Persistence API) e Hibernate como implementaci\u00f3n subyacente.</li> <li>Caracter\u00edsticas clave:<ul> <li>Permite realizar operaciones CRUD (Crear, Leer, Actualizar, Eliminar) sin necesidad de escribir consultas SQL manuales.</li> <li>Soporte para consultas personalizadas y uso de anotaciones para mapear clases a tablas.</li> </ul> </li> </ul> </li> <li>Validation<ul> <li>Prop\u00f3sito: Permite validar los datos de entrada en las solicitudes HTTP utilizando anotaciones.</li> <li>Caracter\u00edsticas clave:<ul> <li>Anotaciones como <code>@NotNull</code>, <code>@Size</code>, y <code>@Email</code> para garantizar que los datos cumplen con las reglas de negocio.</li> <li>Integraci\u00f3n con los controladores REST para devolver errores descriptivos si los datos no son v\u00e1lidos.</li> </ul> </li> </ul> </li> <li>Docker Compose Support<ul> <li>Prop\u00f3sito: Simplifica el desarrollo local al permitir configurar y ejecutar servicios en contenedores Docker directamente desde el entorno de desarrollo.</li> <li>Caracter\u00edsticas clave<ul> <li>Ideal para levantar servicios como PostgreSQL en contenedores sin instalar software adicional.</li> <li>Facilita la colaboraci\u00f3n, ya que todos los servicios se describen en un archivo <code>compose.yaml</code>.</li> </ul> </li> </ul> </li> <li>PostgreSQL Driver<ul> <li>Prop\u00f3sito: Permite que la aplicaci\u00f3n Kotlin se comunique con bases de datos PostgreSQL utilizando JDBC.</li> <li>Caracter\u00edsticas clave:<ul> <li>Implementa el protocolo JDBC necesario para ejecutar consultas SQL desde Spring Data JPA.</li> <li>Necesario para la conexi\u00f3n entre Spring Boot y PostgreSQL.</li> </ul> </li> </ul> </li> <li>Flyway Migration<ul> <li>Prop\u00f3sito: Gestiona las versiones y migraciones del esquema de base de datos de manera controlada y reproducible.</li> <li>Caracter\u00edsticas clave:<ul> <li>Permite ejecutar scripts SQL para crear o modificar tablas.</li> <li>Garantiza que las actualizaciones del esquema sean consistentes en todos los entornos.</li> <li>Los archivos de migraci\u00f3n se almacenan en <code>resources/db/migration/</code>.</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Generaci\u00f3n del Proyecto:</p> <ul> <li>Una vez configuradas todas las opciones, haz clic en el bot\u00f3n GENERATE para descargar el proyecto como un archivo <code>.zip</code>.</li> <li>Extrae el contenido del archivo descargado y \u00e1brelo en IntelliJ IDEA.</li> </ul> </li> <li> <p>Validaci\u00f3n Inicial del Proyecto</p> <ul> <li>Abre el proyecto descargado en IntelliJ IDEA:<ul> <li>Selecciona File &gt; Open y navega al directorio del proyecto.</li> <li>IntelliJ detectar\u00e1 autom\u00e1ticamente que es un proyecto Gradle y configurar\u00e1 las dependencias.</li> </ul> </li> <li>Aseg\u00farate de que las dependencias se instalen correctamente ejecutando:</li> </ul> </li> </ol> <pre><code>./gradlew build\n</code></pre> <p>Esto asegura que no haya errores de configuraci\u00f3n.</p>"},{"location":"#diagrama-de-la-aplicacion","title":"Diagrama de la Aplicaci\u00f3n","text":"<p>El siguiente diagrama ilustra el flujo de la aplicaci\u00f3n y los componentes que se integran para construir, desplegar y probar la API REST con Kotlin, Spring Boot y Google Cloud Platform (GCP):</p> <p></p> <p> Figura # 1: Diagrama de la Aplicaci\u00f3n </p>"},{"location":"#descripcion-del-diagrama","title":"Descripci\u00f3n del Diagrama","text":"<p>El flujo de la aplicaci\u00f3n est\u00e1 compuesto por los siguientes elementos:</p> <ol> <li> <p>Kotlin Application:</p> <ul> <li>Descripci\u00f3n: Este componente corresponde al desarrollo de la API REST utilizando Kotlin y Spring Boot. Es el n\u00facleo de la l\u00f3gica de negocio y la funcionalidad de la aplicaci\u00f3n.</li> <li>Detalles:<ul> <li>Implementa los endpoints RESTful.</li> <li>Gestiona las solicitudes HTTP y realiza operaciones con la base de datos.</li> <li>Emplea herramientas como Spring Data JPA para la persistencia y Flyway para las migraciones.</li> </ul> </li> <li>Rol en el flujo: Genera y gestiona la l\u00f3gica principal de la API REST.</li> </ul> </li> <li> <p>Docker (Solo para PostgreSQL en Local):</p> <ul> <li>Descripci\u00f3n: Durante el desarrollo local, la base de datos PostgreSQL se ejecuta dentro de un contenedor Docker utilizando un archivo de configuraci\u00f3n docker-compose.yml.</li> <li>Detalles:<ul> <li>Proporciona un entorno de base de datos consistente y aislado para pruebas locales.</li> <li>Los datos generados durante el desarrollo se gestionan en el contenedor local, pero no son transferidos autom\u00e1ticamente a la nube.</li> </ul> </li> <li>Rol en el flujo: Simula la base de datos para desarrollo local antes de migrar a Cloud SQL en producci\u00f3n.</li> </ul> </li> <li> <p>Cloud Build:</p> <ul> <li>Descripci\u00f3n: En el flujo de despliegue, el c\u00f3digo fuente de la aplicaci\u00f3n se procesa a trav\u00e9s de Cloud Build, un servicio de Google Cloud que empaqueta el proyecto y genera un archivo JAR para el despliegue.</li> <li>Detalles:<ul> <li>Realiza pasos como pruebas unitarias, validaci\u00f3n del c\u00f3digo y generaci\u00f3n del artefacto (archivo ejecutable).</li> <li>Este artefacto se utiliza posteriormente en App Engine.</li> </ul> </li> <li>Rol en el flujo: Empaqueta y prepara la aplicaci\u00f3n para su despliegue en la nube.</li> </ul> </li> <li> <p>Cloud SQL:</p> <ul> <li>Descripci\u00f3n: En producci\u00f3n, la base de datos local configurada con Docker se reemplaza por Cloud SQL, un servicio gestionado de Google Cloud que ejecuta PostgreSQL.</li> <li>Detalles:<ul> <li>El esquema de la base de datos se migra utilizando Flyway.</li> <li>Proporciona alta disponibilidad, seguridad y escalabilidad para los datos de producci\u00f3n.</li> </ul> </li> <li>Rol en el flujo: Act\u00faa como la base de datos relacional en el entorno de producci\u00f3n.</li> </ul> </li> <li> <p>App Engine:</p> <ul> <li>Descripci\u00f3n: La aplicaci\u00f3n empaquetada en el archivo JAR se despliega en App Engine, una plataforma completamente gestionada por Google Cloud.</li> <li>Detalles:<ul> <li>Escala autom\u00e1ticamente seg\u00fan la carga de usuarios.</li> <li>Gestiona permisos y credenciales para conectarse a Cloud SQL mediante Cloud IAM.</li> </ul> </li> <li>Rol en el flujo: Hacer accesible la API REST desde cualquier lugar a trav\u00e9s de un dominio p\u00fablico.</li> </ul> </li> <li> <p>Cloud IAM:</p> <ul> <li>Descripci\u00f3n: Gestiona los permisos y las pol\u00edticas de seguridad para la conexi\u00f3n entre la aplicaci\u00f3n y los servicios de Google Cloud.</li> <li>Rol en el flujo: Proporciona autenticaci\u00f3n y autorizaci\u00f3n seguras.</li> </ul> </li> <li> <p>Postman:</p> <ul> <li>Descripci\u00f3n: Herramienta utilizada para probar los endpoints de la API REST. Permite enviar solicitudes HTTP para validar las respuestas.</li> <li>Detalles:<ul> <li>Las pruebas se realizan primero contra el entorno local (Docker).</li> <li>Luego, se validan los endpoints desplegados en App Engine.</li> </ul> </li> <li>Rol en el flujo: Garantiza que la API funcione correctamente en ambos entornos.</li> </ul> </li> </ol>"},{"location":"#resumen-del-diagrama","title":"Resumen del Diagrama","text":"Componente Entorno Rol Principal Kotlin Application Local y Nube Contiene la l\u00f3gica de negocio y los controladores. Docker (PostgreSQL) Local Proporciona la base de datos para pruebas locales. Cloud Build Nube Empaqueta y valida la aplicaci\u00f3n para su despliegue. Cloud SQL Nube Base de datos gestionada para el entorno productivo. App Engine Nube Hospeda y escala la API REST en producci\u00f3n. Cloud IAM Nube Gestiona permisos y seguridad. Postman Local y Nube Valida los endpoints de la API en ambos entornos."},{"location":"#objetivo-del-taller","title":"Objetivo del Taller","text":"<p>Al finalizar el taller, los participantes ser\u00e1n capaces de:</p> <ol> <li>Configurar un proyecto Kotlin con Spring Boot desde cero.</li> <li>Gestionar dependencias clave para construir una API REST funcional.</li> <li>Integrar PostgreSQL con Flyway Migration para migraciones controladas.</li> <li>Desplegar y probar la API en Google Cloud App Engine, aprovechando los servicios gestionados como Cloud SQL.</li> <li>Usar herramientas de desarrollo como Docker y Postman para un flujo de trabajo eficiente.</li> </ol>"},{"location":"create_api_rest/","title":"Fase 2: Creaci\u00f3n de la Entidad, Repositorio, Servicio y Controlador","text":"<p>En esta secci\u00f3n implementaremos los componentes principales para nuestra API REST. Adicionalmente, configuraremos Flyway para las migraciones de base de datos y utilizaremos un archivo <code>compose.yaml</code> para ejecutar PostgreSQL localmente.</p>"},{"location":"create_api_rest/#creacion-de-la-api-rest-y-pruebas-locales","title":"Creaci\u00f3n de la API REST y Pruebas Locales","text":""},{"location":"create_api_rest/#estructura-del-proyecto","title":"Estructura del Proyecto","text":"<p>El proyecto est\u00e1 organizado en una estructura clara y modular, siguiendo las mejores pr\u00e1cticas de desarrollo con Spring Boot y Kotlin. La siguiente jerarqu\u00eda de carpetas y archivos refleja c\u00f3mo se distribuyen las responsabilidades dentro del proyecto:</p> <pre><code>src\n \u251c\u2500\u2500 main\n \u2502   \u251c\u2500\u2500 kotlin\n \u2502   \u2502   \u2514\u2500\u2500 com.geovannycode\n \u2502   \u2502       \u251c\u2500\u2500 \ud83d\udcc4 KotlinGcpApplication.kt\n \u2502   \u2502       \u251c\u2500\u2500 \ud83d\udcc4 Speaker.kt\n \u2502   \u2502       \u251c\u2500\u2500 \ud83d\udcc4 SpeakerController.kt\n \u2502   \u2502       \u251c\u2500\u2500 \ud83d\udcc4 SpeakerRepository.kt\n \u2502   \u2502       \u2514\u2500\u2500 \ud83d\udcc4 SpeakerService.kt\n \u2502   \u2514\u2500\u2500 resources\n \u2502       \u251c\u2500\u2500 \ud83d\udcc1 db\n \u2502       \u2502   \u2514\u2500\u2500 migration\n \u2502       \u2502       \u251c\u2500\u2500 \ud83d\udcc4 V1__Create_Speaker_Table.sql\n \u2502       \u2502       \u2514\u2500\u2500 \ud83d\udcc4 V2__Add_Data_Speaker.sql\n \u2502       \u251c\u2500\u2500 \ud83d\udcc1 static\n \u2502       \u251c\u2500\u2500 \ud83d\udcc1 templates\n \u2502       \u2514\u2500\u2500 \ud83d\udcc1 application.properties\n</code></pre> <ul> <li>Paquete principal (<code>com.geovannycode</code>): Aqu\u00ed se encuentran las clases esenciales de la API:<ul> <li><code>KotlinGcpApplication</code>: Es el punto de entrada de la aplicaci\u00f3n. Inicializa Spring Boot y configura el servidor embebido (Tomcat). </li> <li><code>Speaker</code>: Representa la entidad <code>Speaker</code> almacenada en la base de datos. Este modelo mapea los datos relacionales de la tabla PostgreSQL a un objeto Kotlin.</li> <li><code>SpeakerRepository</code>: Define las operaciones necesarias para interactuar con la base de datos. Hereda m\u00e9todos predefinidos de Spring Data JPA como <code>findAll</code>, <code>save</code>, <code>findById</code>, y <code>deleteById</code>.</li> <li><code>SpeakerService</code>: Gestiona la l\u00f3gica de negocio y las validaciones necesarias antes de interactuar con la base de datos.</li> <li><code>SpeakerController</code>: Maneja las solicitudes HTTP y expone los endpoints REST para interactuar con los servicios de la API.</li> </ul> </li> <li>Directorio de recursos (<code>resources</code>):<ul> <li>Este directorio contiene configuraciones y scripts utilizados por la aplicaci\u00f3n.<ul> <li><code>db/migration</code>: Contiene los archivos SQL que Flyway utiliza para crear y modificar el esquema de la base de datos.<ul> <li><code>V1__Create_Speaker_Table.sql</code>: Crea la tabla speakers.</li> <li><code>V2__Add_Data_Speaker.sql</code>: Inserta datos iniciales en la tabla para pruebas.</li> </ul> </li> <li><code>application.properties</code>:<ul> <li>Archivo de configuraci\u00f3n con datos de conexi\u00f3n a la base de datos y otras configuraciones de la aplicaci\u00f3n.</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"create_api_rest/#1-configuracion-local-base-de-datos-con-docker-compose","title":"1. Configuraci\u00f3n Local: Base de Datos con Docker Compose","text":"<p>El archivo <code>compose.yaml</code> es usado para definir y administrar servicios de contenedores. En este caso, configuramos un contenedor de <code>PostgreSQL</code> que servir\u00e1 como nuestra base de datos en el entorno local. A continuaci\u00f3n, explicamos cada secci\u00f3n del archivo.</p> docker-compose.yaml<pre><code>services:\n  postgres_gcp:\n    container_name: \"postgres_gcp\"\n    image: 'postgres:16'\n    env_file: ./.env\n    ports:\n      - ${DB_LOCAL_PORT}:${DB_DOCKER_PORT}\n    environment:\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n      POSTGRES_DB: ${POSTGRES_DB}\n</code></pre> <ul> <li> <p>L\u00ednea 1 <code>services</code>: Define los servicios que se van a levantar con <code>Docker Compose</code>. Aqu\u00ed, configuramos un \u00fanico servicio llamado <code>postgres_gcp</code> que corresponde a un contenedor de <code>PostgreSQL</code>.</p> </li> <li> <p>L\u00ednea 2 <code>postgres_gcp</code>: Nombre del servicio dentro de Docker Compose. Este nombre puede ser utilizado para referenciar el contenedor en redes internas de Docker.</p> </li> <li> <p>L\u00ednea 3 <code>container_name</code>: \"postgres_gcp\" Asigna un nombre al contenedor que ser\u00e1 visible cuando listemos los contenedores con docker ps. En este caso, el contenedor se llamar\u00e1 <code>postgres_gcp</code>.</p> </li> <li> <p>L\u00ednea 4 <code>image</code>: 'postgres:17' Especifica la imagen que ser\u00e1 utilizada para este servicio. Aqu\u00ed usamos la versi\u00f3n <code>17</code> de la imagen oficial de PostgreSQL desde <code>Docker Hub</code>.</p> </li> <li> <p>L\u00ednea 5 <code>env_file: ./env</code> Indica que las variables de entorno ser\u00e1n cargadas desde un archivo llamado <code>.env</code> en el mismo directorio donde est\u00e1 el <code>compose.yaml</code>. Esto permite mantener las credenciales sensibles (como el usuario, contrase\u00f1a y puerto) fuera del archivo principal.</p> </li> <li> <p>L\u00ednea 6 <code>ports</code>: Configura el mapeo de puertos entre el contenedor y el host local.</p> <ul> <li><code>${DB_LOCAL_PORT}:${DB_DOCKER_PORT}</code> Esto utiliza las variables definidas en el archivo <code>.env</code>. El puerto local (<code>DB_LOCAL_PORT</code>) estar\u00e1 conectado al puerto del contenedor (<code>DB_DOCKER_PORT</code>). Por ejemplo, si definimos <code>DB_LOCAL_PORT=5432</code>, la base de datos ser\u00e1 accesible en <code>localhost:5432</code>.</li> </ul> </li> <li> <p>L\u00ednea 7 <code>environment</code>: Declara las variables de entorno necesarias para configurar PostgreSQL en el contenedor.</p> <ul> <li><code>POSTGRES_USER</code>: Define el nombre del usuario administrador de la base de datos.</li> <li><code>POSTGRES_PASSWORD</code>: Asigna la contrase\u00f1a del usuario administrador.</li> <li><code>POSTGRES_DB</code>: Especifica el nombre de la base de datos principal que se crear\u00e1 autom\u00e1ticamente cuando el contenedor se inicie.</li> </ul> </li> <li> <p>Puntos Clave</p> <ol> <li>Configura las variables en el archivo <code>.env</code>: Personaliza los valores como el puerto local, usuario y nombre de la base de datos.</li> <li>Automatizaci\u00f3n con Docker Support: Si est\u00e1s utilizando Docker Support integrado en IntelliJ IDEA o tu herramienta de desarrollo, no es necesario ejecutar comandos manuales (<code>docker-compose up</code>). Al iniciar tu aplicaci\u00f3n Spring Boot, Docker Support levanta autom\u00e1ticamente el contenedor de PostgreSQL. Esto simplifica el flujo de desarrollo.</li> </ol> </li> <li> <p>Ventajas de Docker Compose con Docker Support</p> <ul> <li>Ahorro de tiempo: No necesitas ejecutar manualmente <code>docker-compose</code> siempre que inicies tu aplicaci\u00f3n Spring Boot.</li> <li>Integraci\u00f3n: Docker Support coordina autom\u00e1ticamente la creaci\u00f3n y administraci\u00f3n del contenedor.</li> <li>Estandarizaci\u00f3n: Al definir configuraciones en <code>.env</code>, todos los miembros del equipo pueden usar los mismos valores base.</li> </ul> </li> </ul>"},{"location":"create_api_rest/#2-migraciones-con-flyway","title":"2. Migraciones con Flyway","text":"<p>Flyway es una herramienta de migraci\u00f3n de base de datos que permite gestionar de forma controlada los cambios en el esquema y los datos iniciales. En este caso, utilizaremos Flyway para crear la tabla speakers y a\u00f1adir datos iniciales en PostgreSQL.</p>"},{"location":"create_api_rest/#21-archivos-de-migracion","title":"2.1 Archivos  de Migraci\u00f3n","text":"<p>Flyway organiza los cambios en la base de datos mediante archivos de migraci\u00f3n con un formato espec\u00edfico en el nombre, por ejemplo: <code>V1__Create_Speaker_Table.sql</code> y <code>V2__Add_Data_Speaker.sql</code>.</p> <ul> <li><code>V1__Create_Speaker_Table.sql</code> Este archivo contiene las instrucciones para crear la tabla <code>speakers</code> y su secuencia de IDs.</li> </ul> V1__Create_Speaker_Table.sql<pre><code>CREATE SEQUENCE speaker_id_seq START 1 INCREMENT BY 50;\n\nCREATE TABLE speakers (\n    id BIGINT DEFAULT nextval('speaker_id_seq') NOT NULL,\n    name VARCHAR(255) NOT NULL,\n    country VARCHAR(255) NOT NULL,\n    PRIMARY KEY (id)\n);\n</code></pre> <ul> <li><code>V2__Add_Data_Speaker.sql</code> Este archivo agrega un registro inicial en la tabla <code>speakers</code> para facilitar las pruebas.</li> </ul> V2__Add_Data_Speaker.sql<pre><code>INSERT INTO speakers (id, name, country) VALUES (nextval('speaker_id_seq'), 'Geovanny Mendoza', 'Colombia');\n</code></pre>"},{"location":"create_api_rest/#22-ubicacion-de-los-archivos","title":"2.2 Ubicaci\u00f3n de los Archivos","text":"<ul> <li> <p>Los archivos de migraci\u00f3n deben estar ubicados en el directorio: <code>src/main/resources/db/migration</code>.</p> </li> <li> <p>Esto es importante porque Flyway, por defecto, escanea esta ruta para aplicar las migraciones.</p> </li> </ul>"},{"location":"create_api_rest/#23-flujo-de-migracion","title":"2.3 Flujo de Migraci\u00f3n","text":"<ul> <li>Inicio de la aplicaci\u00f3n: Spring Boot detecta las configuraciones de Flyway y se conecta a la base de datos.</li> <li>Verifica las migraciones pendientes: Flyway consulta la tabla <code>flyway_schema_history</code> en la base de datos (si no existe, la crea autom\u00e1ticamente) para determinar qu\u00e9 migraciones a\u00fan no se han aplicado.</li> <li>Aplica las migraciones: Flyway ejecuta los archivos en orden de versi\u00f3n (por ejemplo, <code>V1</code>, <code>V2</code>, etc.).</li> <li>Registro en <code>flyway_schema_history</code>: Una vez aplicada una migraci\u00f3n, Flyway registra el nombre del archivo, el estado y la fecha en esta tabla.</li> </ul>"},{"location":"create_api_rest/#24-ventajas-de-flyway","title":"2.4 Ventajas de Flyway","text":"<ul> <li>Control de versiones: Cada cambio en el esquema est\u00e1 versionado y registrado.</li> <li>Automatizaci\u00f3n: Al iniciar la aplicaci\u00f3n, Flyway aplica autom\u00e1ticamente las migraciones pendientes.</li> <li>Reversibilidad: Facilita el mantenimiento de la base de datos al permitir manejar m\u00faltiples entornos con un esquema consistente.</li> </ul>"},{"location":"create_api_rest/#3-implementacion-tecnica","title":"3. Implementaci\u00f3n T\u00e9cnica","text":"<p>Punto de Entrada: <code>KotlinGcpApplication.kt</code></p> <p>El archivo <code>KotlinGcpApplication.kt</code> define el punto de entrada principal de nuestra aplicaci\u00f3n. Es aqu\u00ed donde Spring Boot inicia todo el proceso de configuraci\u00f3n, creaci\u00f3n de beans y levantamiento del servidor embebido (<code>Tomcat</code>).</p> KotlinGcpApplication.kt<pre><code>@SpringBootApplication\nclass KotlinGcpApplication\n\nfun main(args: Array&lt;String&gt;) {\n    runApplication&lt;KotlinGcpApplication&gt;(*args)\n}\n</code></pre> <p>Esta clase define el punto de entrada de la aplicaci\u00f3n:</p> <ul> <li>L\u00ednea 1 <code>@SpringBootApplication</code>:  Esta anotaci\u00f3n combina tres anotaciones clave de Spring Boot:<ul> <li><code>@Configuration</code>: Marca la clase como una fuente de configuraciones de Spring.</li> <li><code>@EnableAutoConfiguration</code>: Activa la configuraci\u00f3n autom\u00e1tica de Spring Boot, cargando los componentes seg\u00fan las dependencias declaradas.</li> <li><code>@ComponentScan</code>: Escanea autom\u00e1ticamente el paquete actual y sus subpaquetes en busca de clases anotadas como <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, etc., para registrarlas como beans en el contexto de la aplicaci\u00f3n.</li> </ul> </li> <li>L\u00ednea 2 <code>class KotlinGcpApplication</code>: <ul> <li>Define una clase vac\u00eda con el nombre de la aplicaci\u00f3n. Aunque no contiene l\u00f3gica adicional, Spring Boot la utiliza como punto central para identificar el contexto principal de la aplicaci\u00f3n.</li> <li>Nota: El nombre de la clase es arbitrario, pero debe ser \u00fanico dentro del paquete y representativo de la funcionalidad de la aplicaci\u00f3n.</li> </ul> </li> <li>L\u00ednea 4: <code>fun main(args: Array&lt;String&gt;)</code><ul> <li>Define la funci\u00f3n <code>main</code>, que es el punto de entrada est\u00e1ndar para cualquier aplicaci\u00f3n escrita en Kotlin. Aqu\u00ed es donde comienza la ejecuci\u00f3n del programa.</li> </ul> </li> <li>L\u00ednea 5 <code>runApplication&lt;KotlinGcpApplication&gt;(*args)</code>: Esta l\u00ednea ejecuta la funci\u00f3n <code>runApplication</code>, que realiza las siguientes tareas:<ul> <li>Inicia Spring Boot: Configura el contexto de la aplicaci\u00f3n y todos los beans necesarios.</li> <li>Levanta el Servidor Embebido: En este caso, inicia un servidor Tomcat que se ejecuta en el puerto <code>8080</code> por defecto.</li> <li>Carga los Recursos de Configuraci\u00f3n: Como <code>application.properties</code> o <code>application.yml</code>, que contienen configuraciones clave como la conexi\u00f3n a la base de datos.</li> <li>Procesa los Argumentos: Los par\u00e1metros pasados en <code>args</code> se interpretan como argumentos de l\u00ednea de comandos para personalizar el comportamiento de la aplicaci\u00f3n en tiempo de ejecuci\u00f3n.</li> </ul> </li> </ul> <p>Nota: El operador <code>*</code> delante de <code>args</code> se llama spread operator en Kotlin. Descompone el arreglo de argumentos para que puedan ser pasados individualmente como par\u00e1metros a la funci\u00f3n <code>runApplication</code>.</p>"},{"location":"create_api_rest/#31-modelo-de-datos-speakerkt","title":"3.1 Modelo de Datos: <code>Speaker.kt</code>","text":"<p>La clase <code>Speaker.kt</code> define el modelo de datos que representa la tabla <code>speakers</code> en la base de datos. Es una entidad JPA (Java Persistence API) que Spring Data utiliza para mapear autom\u00e1ticamente los registros de la base de datos a objetos Kotlin.</p> Speaker.kt<pre><code>@Entity\n@Table(name = \"speakers\")\ndata class Speaker(\n    @Id\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"speaker_id_generator\")\n    @SequenceGenerator(name = \"speaker_id_generator\", sequenceName = \"speaker_id_seq\")\n    val id: Long? = null,\n    val name: String,\n    val country: String\n)\n</code></pre> <ul> <li>L\u00ednea 1 <code>@Entity</code>: <ul> <li>Marca la clase como una entidad JPA, lo que indica que est\u00e1 vinculada a una tabla en la base de datos.</li> <li><code>Spring Boot</code>: Detecta esta anotaci\u00f3n durante el escaneo de componentes (gracias a <code>@SpringBootApplication</code>) y registra autom\u00e1ticamente la clase como una entidad administrada.</li> </ul> </li> <li>L\u00ednea 2: <code>@Table(name = \"speakers\")</code>:<ul> <li>Especifica el nombre de la tabla en la base de datos asociada con esta entidad.</li> </ul> </li> <li>L\u00ednea 3 <code>data class</code>: <ul> <li>La clase <code>Speaker</code> est\u00e1 definida como una data class, lo que aporta las siguientes ventajas:<ul> <li>Inmutabilidad:<ul> <li>Los valores de las propiedades son constantes (<code>val</code>) y no pueden ser modificados despu\u00e9s de la creaci\u00f3n del objeto.</li> <li>Esto es \u00fatil en aplicaciones donde los datos no deben cambiarse accidentalmente.</li> </ul> </li> <li>M\u00e9todos Autom\u00e1ticos Generados:<ul> <li><code>toString</code>: Proporciona una representaci\u00f3n de texto para imprimir f\u00e1cilmente los objetos.</li> <li><code>equals</code> y <code>hashCode</code>: Facilitan la comparaci\u00f3n entre objetos.</li> <li><code>copy</code>: Permite crear una nueva instancia basada en un objeto existente con cambios en algunas propiedades.</li> </ul> </li> <li>Compatibilidad con Kotlin/JPA:<ul> <li>Las <code>data class</code> se integran bien con JPA, siempre que cumplan las reglas b\u00e1sicas (como constructor primario completo).</li> </ul> </li> </ul> </li> </ul> </li> <li>L\u00ednea 4 <code>@Id</code>: Define este campo como la clave primaria de la tabla.</li> <li>L\u00ednea 5 <code>@GeneratedValue</code>: Especifica que el valor de este campo ser\u00e1 generado autom\u00e1ticamente.<ul> <li><code>strategy = GenerationType.SEQUENCE</code>: Usa una estrategia de secuencia, que es eficiente para PostgreSQL.</li> <li><code>generator = \"speaker_id_generator\"</code>: Asocia este campo a un generador de secuencias espec\u00edfico.</li> </ul> </li> <li>L\u00ednea 6 <code>SequenceGenerator</code>: Configura el generador de secuencias.<ul> <li><code>name = \"speaker_id_generator\"</code>: Nombre del generador asociado.</li> <li><code>sequenceName = \"speaker_id_seq\"</code>: Nombre de la secuencia en la base de datos que generar\u00e1 los valores del campo <code>id</code>.</li> </ul> </li> <li>L\u00ednea 7: <code>Nullable</code> Se define como <code>Long? = null</code> porque el valor inicial es <code>null</code> hasta que se genera autom\u00e1ticamente al guardar el registro.</li> <li>Campos:<ul> <li><code>id</code>: Clave primaria generada autom\u00e1ticamente usando una secuencia PostgreSQL.</li> <li><code>name</code>: Almacena el nombre del speaker.</li> <li><code>country</code>: Almacena el pa\u00eds de origen del speaker.</li> </ul> </li> </ul>"},{"location":"create_api_rest/#32-repositorio-speakerrepositorykt","title":"3.2 Repositorio: <code>SpeakerRepository.kt</code>","text":"<p>El repositorio es una interfaz que permite interactuar con la base de datos de manera directa, manejando operaciones CRUD (<code>Crear, Leer, Actualizar y Eliminar</code>) sin necesidad de escribir c\u00f3digo SQL manualmente. En este caso, <code>SpeakerRepository</code> hereda de <code>CrudRepository</code>, una clase proporcionada por Spring Data JPA.</p> SpeakerRepository.kt<pre><code>@Repository\ninterface SpeakerRepository : CrudRepository&lt;Speaker, Long&gt;\n</code></pre> <ul> <li>L\u00ednea 2: <code>interface SpeakerRepository : CrudRepository&lt;Speaker, Long&gt;</code><ul> <li><code>interface</code>: Define que <code>SpeakerRepository</code> es una interfaz, no una clase.</li> <li><code>: CrudRepository&lt;Speaker, Long&gt;</code>:<ul> <li><code>CrudRepository</code> es una interfaz gen\u00e9rica que requiere dos par\u00e1metros:</li> <li><code>Speaker</code>: Es la entidad sobre la que este repositorio operar\u00e1.</li> <li><code>Long</code>: Es el tipo de dato de la clave primaria de la entidad Speaker.</li> </ul> </li> </ul> </li> </ul> <p>Nota Importante: Spring implementa autom\u00e1ticamente esta interfaz al detectar su definici\u00f3n durante el escaneo de componentes. No es necesario escribir c\u00f3digo adicional para implementar esta interfaz, lo que ahorra tiempo y esfuerzo.</p> <ul> <li>Este repositorio hereda de <code>CrudRepository</code>, proporcionando m\u00e9todos como:<ul> <li><code>findById</code>: Busca un registro por su ID.</li> <li><code>findAll</code>: Devuelve todos los registros.</li> <li><code>save</code>: Guarda o actualiza un registro.</li> <li><code>deleteById</code>: Elimina un registro por ID.</li> </ul> </li> </ul>"},{"location":"create_api_rest/#33-servicio-speakerservicekt","title":"3.3 Servicio: <code>SpeakerService.kt</code>","text":"<p>El archivo <code>SpeakerService.kt</code> implementa la l\u00f3gica de negocio para la API REST. Act\u00faa como un intermediario entre el controlador y el repositorio, asegurando que las operaciones CRUD (<code>Crear, Leer, Actualizar y Eliminar</code>) se realicen de manera controlada.</p> SpeakerService.kt<pre><code>@Service\n@Transactional\nclass SpeakerService(val repo: SpeakerRepository) {\n    fun getSpeakers(): List&lt;Speaker&gt; = repo.findAll().toList()\n    fun getSpeaker(id: Long) = repo.findById(id)\n    fun createSpeaker(speaker: Speaker) = repo.save(speaker)\n    fun deleteSpeaker(id: Long) = repo.deleteById(id)\n    fun updateSpeaker(id: Long, updatedSpeaker: Speaker): Speaker? {\n        return if (repo.existsById(id)) {\n            val speakerToUpdate = updatedSpeaker.copy(id = id)\n            repo.save(speakerToUpdate)\n        } else {\n            null\n        }\n    }\n}\n</code></pre> <ul> <li>L\u00ednea 1: <code>@Service</code> Marca esta clase como un servicio administrado por Spring. Spring Boot Detecta autom\u00e1ticamente esta anotaci\u00f3n durante el escaneo de componentes y la registra como un <code>bean</code> disponible en el contenedor de la aplicaci\u00f3n.<ul> <li>Ventaja: Permite inyectar esta clase en otros componentes (<code>como el controlador)</code> sin necesidad de inicializarla manualmente.</li> </ul> </li> <li>L\u00ednea 2: <code>@Transactional</code> Garantiza que todas las operaciones dentro de este servicio se ejecuten dentro de una transacci\u00f3n.<ul> <li>Ventajas:<ul> <li>Si ocurre un error en cualquier parte del m\u00e9todo, todas las operaciones realizadas dentro de la transacci\u00f3n ser\u00e1n revertidas.</li> <li>Asegura consistencia en la base de datos.</li> </ul> </li> </ul> </li> <li>L\u00ednea 3 <code>Constructor: private val repo: SpeakerRepository</code><ul> <li>Inyecta autom\u00e1ticamente el repositorio <code>SpeakerRepository</code> en el servicio.</li> <li>Esto permite acceder a los m\u00e9todos predefinidos en <code>CrudRepository</code> (como <code>findAll</code>, <code>save</code>, etc.) para interactuar con la base de datos.</li> </ul> </li> <li>L\u00ednea 4 <code>getSpeakers</code>: Devuelve una lista de todos los registros en la tabla speakers.<ul> <li>Detalle:<ul> <li><code>repo.findAll()</code>: Devuelve un <code>Iterable&lt;Speaker&gt;</code>.</li> <li><code>.toList()</code>: Convierte el iterable en una lista, que es m\u00e1s f\u00e1cil de manejar.</li> </ul> </li> </ul> </li> <li>L\u00ednea 5 <code>getSpeaker</code>: Busca un registro por su clave primaria (<code>id</code>) y lo devuelve. Si no existe, devuelve <code>null</code>.<ul> <li>Detalle:<ul> <li><code>repo.findById(id)</code>: Devuelve un <code>Optional&lt;Speaker&gt;</code>.</li> <li><code>.orElse(null)</code>: Extrae el valor si existe, o devuelve <code>null</code> si no lo encuentra.</li> </ul> </li> </ul> </li> <li>L\u00ednea 6 <code>createSpeaker</code>: Inserta un nuevo registro en la base de datos.<ul> <li>Detalle:<ul> <li><code>repo.save(speaker)</code>: Guarda el objeto <code>Speaker</code> en la base de datos y devuelve la entidad guardada con su clave primaria (<code>id</code>) asignada.</li> </ul> </li> </ul> </li> <li>L\u00ednea 7 <code>deleteSpeaker</code>: Elimina un registro por su clave primaria (id).<ul> <li>Detalle:<ul> <li><code>repo.deleteById(id)</code>: Elimina el registro correspondiente en la base de datos.</li> </ul> </li> </ul> </li> <li>L\u00ednea 8 <code>updateSpeaker</code>: Actualiza un registro existente en la base de datos. Si no existe, devuelve null.<ul> <li>Detalle:<ul> <li><code>repo.existsById(id)</code>: Verifica si el registro con el <code>id</code> especificado existe.</li> <li><code>updatedSpeaker.copy(id = id)</code>: Crea una nueva instancia del objeto <code>Speaker</code> con el id correcto.</li> <li><code>repo.save(speakerToUpdate)</code>: Guarda el registro actualizado.</li> </ul> </li> </ul> </li> </ul>"},{"location":"create_api_rest/#34-controlador-rest-speakercontrollerkt","title":"3.4 Controlador REST: <code>SpeakerController.kt</code>","text":"<p>El controlador REST es la capa que expone la l\u00f3gica de negocio a trav\u00e9s de la red utilizando la arquitectura REST (Representational State Transfer). Esto permite interactuar con la API mediante solicitudes HTTP est\u00e1ndar como <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, entre otros.</p> <p>\u00bfPor Qu\u00e9 @RestController?</p> <ul> <li><code>@RestController</code> es una anotaci\u00f3n de Spring que combina <code>@Controller</code> y <code>@ResponseBody</code>.</li> <li> <p>Todos los m\u00e9todos en una clase marcada como <code>@RestController</code> retornan autom\u00e1ticamente los datos en formato JSON o XML, seg\u00fan lo que soporte el cliente.</p> </li> <li> <p>Ventajas:</p> <ul> <li>Simplifica la creaci\u00f3n de controladores RESTful al eliminar la necesidad de agregar <code>@ResponseBody</code> en cada m\u00e9todo.</li> <li>Los datos devueltos por los m\u00e9todos no se renderizan como vistas HTML (como lo har\u00eda un <code>@Controller</code> tradicional), sino como una respuesta HTTP con un cuerpo en formato JSON.</li> </ul> </li> <li> <p>Arquitectura REST:</p> <ul> <li>REST sigue los principios HTTP para operar con recursos.</li> <li>Cada recurso tiene una representaci\u00f3n \u00fanica (en este caso, la entidad Speaker) y puede ser manipulado utilizando verbos HTTP.</li> </ul> </li> </ul> SpeakerController.kt<pre><code>@RestController\n@RequestMapping(\"/api/speakers\")\nclass SpeakerController(private val service: SpeakerService) {\n\n    // 1. Recuperar todos los registros\n    @GetMapping\n    fun getSpeakers(): ResponseEntity&lt;List&lt;Speaker&gt;&gt; =\n        ResponseEntity.ok(service.getSpeakers())\n\n    // 2. Recuperar un registro por ID\n    @GetMapping(\"/{id}\")\n    fun getSpeaker(@PathVariable id: Long): ResponseEntity&lt;Speaker&gt; =\n        service.getSpeaker(id).map { ResponseEntity.ok(it) }\n            .orElse(ResponseEntity.notFound().build())\n\n    // 3. Crear un nuevo registro\n    @PostMapping\n    fun createSpeaker(@RequestBody speaker: Speaker): ResponseEntity&lt;Speaker&gt; =\n        ResponseEntity.ok(service.createSpeaker(speaker))\n\n    // 4. Eliminar un registro por ID\n    @DeleteMapping(\"/{id}\")\n    fun deleteSpeaker(@PathVariable id: Long): ResponseEntity&lt;Void&gt; {\n        service.deleteSpeaker(id)\n        return ResponseEntity.noContent().build()\n    }\n\n    // 5. Actualizar un registro existente\n    @PutMapping(\"/{id}\")\n    fun updateSpeaker(@PathVariable id: Long, @RequestBody updatedSpeaker: Speaker): ResponseEntity&lt;Speaker&gt; {\n        val updated = service.updateSpeaker(id, updatedSpeaker)\n        return if (updated != null) {\n            ResponseEntity.ok(updated)\n        } else {\n            ResponseEntity.notFound().build()\n        }\n    }\n}\n</code></pre> <p>Este archivo expone los endpoints para interactuar con la API:</p> <ul> <li> <p>L\u00edneas 6-8: Define el m\u00e9todo que maneja solicitudes <code>GET</code> en el endpoint <code>/api/speakers</code>.</p> <ul> <li>Permitir al cliente obtener una lista de todos los <code>Speaker</code> registrados en la base de datos.</li> <li>Anotaciones importantes: <code>@GetMapping</code> Especifica que este m\u00e9todo manejar\u00e1 solicitudes HTTP con el verbo <code>GET</code>. Este tipo de solicitud se utiliza com\u00fanmente para recuperar informaci\u00f3n sin modificar el estado del servidor.</li> <li>Flujo del m\u00e9todo: Llama al servicio (<code>service.getSpeakers()</code>) para recuperar una lista con todos los registros de <code>Speaker</code>.<ul> <li>Devuelve un <code>ResponseEntity</code> con:<ul> <li>C\u00f3digo HTTP <code>200 OK</code>, que indica \u00e9xito en la solicitud.</li> <li>Cuerpo de la respuesta: Un listado JSON con los objetos <code>Speaker</code>.</li> </ul> </li> <li>C\u00f3digos de respuesta:<ul> <li>200 OK: Indica que la solicitud fue exitosa. Si no hay speakers registrados, se devuelve una lista vac\u00eda.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>L\u00edneas 11-14: Define el m\u00e9todo que maneja solicitudes <code>GET</code>con un par\u00e1metro din\u00e1mico (<code>id</code>) en el endpoint <code>/api/speakers/{id}</code>.</p> <ul> <li>Permitir al cliente recuperar la informaci\u00f3n de un <code>Speaker</code> espec\u00edfico usando su ID \u00fanico.</li> <li>Anotaciones importantes: <code>@GetMapping(\"/{id}\")</code> Asigna este m\u00e9todo a solicitudes <code>GET</code> con un identificador din\u00e1mico (<code>{id}</code>) en la URL. y con el <code>@PathVariable</code> Extrae el valor <code>{id}</code> de la URL y lo asigna al par\u00e1metro <code>id</code>. Esto facilita el uso de rutas din\u00e1micas.</li> <li>Flujo del m\u00e9todo: El servidor recibe la solicitud con el ID proporcionado en la URL.<ul> <li>Llama al servicio (<code>service.getSpeaker(id)</code>) para buscar el <code>Speaker</code> correspondiente.</li> <li>Si el registro es encontrado devuelve un <code>ResponseEntity</code> con:<ul> <li>C\u00f3digo HTTP <code>200 OK</code>, que indica \u00e9xito en la solicitud.</li> <li>Cuerpo de la respuesta: El objeto <code>Speaker</code> encontrado.</li> </ul> </li> <li>Si no existe devuelve un <code>ResponseEntity</code> con:<ul> <li>C\u00f3digo HTTP <code>404 Not Found</code>, indicando que el recurso solicitado no existe.</li> </ul> </li> <li>C\u00f3digos de respuesta:<ul> <li><code>200 OK</code>: El <code>Speaker</code> fue encontrado exitosamente.</li> <li><code>404 Not Found</code>: No se encontr\u00f3 ning\u00fan registro con el ID proporcionado.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>L\u00edneas 17-19: Define el m\u00e9todo que maneja solicitudes <code>POST</code> en el endpoint <code>/api/speakers</code>.</p> <ul> <li>Este m\u00e9todo permite al cliente crear un nuevo registro de <code>Speaker</code> enviando los datos en formato <code>JSON</code>. Utiliza el servicio (<code>service.createSpeaker</code>) para procesar y almacenar el objeto recibido en la base de datos.</li> <li>Anotaciones importantes: <code>@PostMapping</code> Especifica que este m\u00e9todo responder\u00e1 a solicitudes <code>HTTP</code> con el verbo <code>POST</code>. Este tipo de solicitud se utiliza com\u00fanmente para crear nuevos recursos en un servidor. Por otro lado el  <code>@RequestBody</code> indica que el cuerpo de la solicitud HTTP (<code>enviado por el cliente</code>) ser\u00e1 deserializado autom\u00e1ticamente a un objeto <code>Speaker</code>. Esto simplifica la lectura de datos <code>JSON</code> enviados por el cliente.</li> <li>Flujo del m\u00e9todo: Recibe un objeto JSON en el cuerpo de la solicitud (por ejemplo, un Speaker con atributos como name y country).<ul> <li>Convierte este <code>JSON</code> a un objeto <code>Speaker</code> usando la anotaci\u00f3n <code>@RequestBody</code>.</li> <li>Llama al servicio (<code>service.createSpeaker(speaker)</code>) para guardar este objeto en la base de datos.</li> <li>Devuelve un <code>ResponseEntity</code> con:<ul> <li>C\u00f3digo HTTP <code>200 OK</code> indicando que la solicitud se proces\u00f3 correctamente.</li> <li>Cuerpo de la respuesta: El objeto Speaker reci\u00e9n creado, con su <code>id</code> generado autom\u00e1ticamente por la base de datos.</li> </ul> </li> <li>C\u00f3digos de respuesta:<ul> <li><code>200 OK</code>: Se devuelve cuando el objeto se crea correctamente.</li> <li><code>Errores</code>: No se manejan errores expl\u00edcitos en este m\u00e9todo, pero posibles problemas (como validaci\u00f3n fallida) se deben manejar en otro nivel (por ejemplo, en las anotaciones de validaci\u00f3n).</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>L\u00edneas 22-26: Define el m\u00e9todo que maneja solicitudes <code>DELETE</code> en el endpoint <code>/api/speakers/{id}</code>.</p> <ul> <li>Permitir al cliente eliminar un <code>Speaker</code> espec\u00edfico usando su <code>ID</code> \u00fanico.</li> <li>Anotaciones importantes: <code>@DeleteMapping(\"/{id}\")</code> Asigna este m\u00e9todo a solicitudes <code>DELETE</code> con un identificador din\u00e1mico en la <code>URL</code> y el <code>@PathVariable</code> Extrae el valor <code>{id}</code> de la URL y lo asigna al par\u00e1metro <code>id</code>.</li> <li>Flujo del m\u00e9todo: El servidor recibe la solicitud con el ID del recurso a eliminar.<ul> <li>Llama al servicio (service.deleteSpeaker(id)) para realizar la eliminaci\u00f3n en la base de datos.</li> <li>Devuelve un ResponseEntity con:<ul> <li>C\u00f3digo HTTP <code>200 OK</code>, que indica \u00e9xito en la solicitud.</li> </ul> </li> <li>C\u00f3digos de respuesta:<ul> <li><code>204 No Content</code>: El Speaker fue eliminado exitosamente.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>L\u00edneas 29-37: Define el m\u00e9todo que maneja solicitudes <code>PUT</code> en el endpoint <code>/api/speakers/{id}</code>.</p> <ul> <li>Permitir al cliente actualizar un registro existente de <code>Speaker</code> enviando los nuevos datos en formato <code>JSON</code>.</li> <li>Anotaciones importantes: <code>@PutMapping(\"/{id}\")</code> Asigna este m\u00e9todo a solicitudes <code>PUT</code> con un identificador din\u00e1mico en la URL. y <code>@PathVariable</code> Extrae el valor <code>{id}</code> de la URL y lo asigna al par\u00e1metro <code>id</code> y por ultimo <code>@RequestBody</code> que convierte el cuerpo <code>JSON</code> de la solicitud en un objeto Speaker.</li> <li>Flujo del m\u00e9todo: Recibe un objeto JSON con los nuevos datos del Speaker.<ul> <li>Llama al servicio (<code>service.updateSpeaker(id, updatedSpeaker)</code>) para realizar la actualizaci\u00f3n.</li> <li>Si el registro existe devuelve un <code>ResponseEntity</code> con:<ul> <li>C\u00f3digo HTTP <code>200 OK</code>.</li> <li>Cuerpo de la respuesta: El objeto Speaker actualizado.</li> </ul> </li> <li>Si no existe devuelve un <code>ResponseEntity</code> con:<ul> <li>C\u00f3digo HTTP <code>404 Not Found</code></li> </ul> </li> <li>C\u00f3digos de respuesta:<ul> <li><code>200 OK</code>: El <code>Speaker</code> fue actualizado exitosamente.</li> <li><code>404 Not Found</code>: No existe un registro con el ID proporcionado.</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"create_api_rest/#4-pruebas-locales-con-postman","title":"4. Pruebas Locales con Postman","text":"<p>Una vez que la <code>API REST</code> est\u00e1 implementada y la base de datos configurada, podemos probar los endpoints utilizando Postman, una herramienta de pruebas para APIs REST.</p> <p>La <code>Figura #1</code> muestra un ejemplo de la respuesta al probar este endpoint con <code>Postman</code>.</p> <p></p> <p> Figura # 1: Representaci\u00f3n del Postman </p> <ul> <li>Ejemplo:<ul> <li><code>GET /api/speakers</code>: Recupera todos los speakers.</li> <li><code>POST /api/speakers</code>: Crea un nuevo speaker con este JSON:     <pre><code>{\n    \"name\": \"John Doe\",\n    \"country\": \"USA\"\n}\n</code></pre></li> <li><code>PUT /api/speakers/{id}</code>: Actualiza un speaker.</li> <li><code>DELETE /api/speakers/{id}</code>: Elimina un speaker.</li> </ul> </li> </ul>"},{"location":"create_api_rest/#5-continuacion-del-proyecto","title":"5. Continuaci\u00f3n del Proyecto","text":"<p>En la pr\u00f3xima <code>sesi\u00f3n/documento</code>, avanzaremos con la integraci\u00f3n de esta API REST en <code>Google Cloud Platform (GCP)</code>. </p> <ul> <li>Exploraremos las siguientes tareas:<ul> <li>Despliegue de la aplicaci\u00f3n en App Engine.</li> <li>Configuraci\u00f3n de la base de datos en Cloud SQL.</li> <li>Automatizaci\u00f3n del flujo de despliegue utilizando Cloud Build.</li> </ul> </li> </ul> <p>\u00a1Prep\u00e1rate para llevar esta aplicaci\u00f3n a la nube! \ud83d\ude80</p>"},{"location":"create_api_rest/#6-resumen-general","title":"6. Resumen General","text":"<p>En este taller, desarrollamos una API REST con Kotlin, Spring Boot y PostgreSQL. </p> <p>Los pasos principales fueron:</p> <ul> <li> <p>Configuraci\u00f3n del Proyecto: </p> <ul> <li>Usamos <code>Spring Initializr</code> para generar el proyecto con dependencias clave.</li> <li>Organizamos el c\u00f3digo en paquetes y recursos para una estructura clara.</li> </ul> </li> <li> <p>Implementaci\u00f3n de la API:</p> <ul> <li>Creamos la entidad <code>Speaker</code>, el repositorio <code>SpeakerRepository</code>, el servicio <code>SpeakerService</code> y el controlador <code>SpeakerController</code> para exponer endpoints REST (<code>GET, POST, PUT, DELETE</code>).</li> <li>Implementamos l\u00f3gica de negocio para gestionar operaciones <code>CRUD</code>.</li> </ul> </li> <li> <p>Base de Datos Local:</p> <ul> <li>Configuramos PostgreSQL con Docker Compose.</li> <li>Usamos Flyway para manejar migraciones de base de datos y datos iniciales.</li> </ul> </li> <li> <p>Pruebas Locales:</p> <ul> <li>Probamos los endpoints con Postman, verificando c\u00f3digos de respuesta (<code>200 OK, 404 Not Found, etc.</code>) y datos retornados en formato <code>JSON</code>.</li> </ul> </li> <li> <p>Pr\u00f3ximos Pasos</p> <ul> <li>En la pr\u00f3xima sesi\u00f3n, desplegaremos esta API en <code>Google Cloud Platform (GCP)</code> utilizando <code>App Engine</code>, <code>Cloud SQL</code> y <code>Cloud Build</code>.</li> </ul> </li> </ul>"},{"location":"despliegue_gcp/","title":"Despliegue de una API REST con Kotlin en Google Cloud con PostgreSQL","text":""},{"location":"despliegue_gcp/#introduccion","title":"Introducci\u00f3n","text":"<p>El desarrollo y despliegue de aplicaciones modernas en la nube permite a los desarrolladores crear APIs robustas, escalables y seguras. En esta gu\u00eda aprender\u00e1s a desplegar una API REST construida con Kotlin y Spring Boot en Google Cloud App Engine, con PostgreSQL como base de datos.</p> <p>Este proceso incluye la configuraci\u00f3n de un proyecto en Google Cloud, la creaci\u00f3n de una instancia de base de datos en Cloud SQL, y el despliegue de la aplicaci\u00f3n en un entorno gestionado con soporte de escalabilidad autom\u00e1tica. Tambi\u00e9n integraremos herramientas como Google Cloud SDK para facilitar la gesti\u00f3n y despliegue de recursos.</p>"},{"location":"despliegue_gcp/#paso-1-configuracion-del-proyecto-en-google-cloud","title":"Paso 1: Configuraci\u00f3n del Proyecto en Google Cloud","text":"<ol> <li>Creaci\u00f3n de un Proyecto en Google Cloud</li> </ol> <p>Antes de iniciar, aseg\u00farate de haber iniciado sesi\u00f3n en tu cuenta de Google Cloud.</p> <ul> <li>En el panel principal de Google Cloud, selecciona la opci\u00f3n \"Nuevo Proyecto\" como se muestra en la Figura #1: </li> </ul> <p> Figura # 1: Nuevo Proyecto </p> <ul> <li>En la pantalla emergente, asigna un nombre al proyecto, por ejemplo, <code>demo-kotlin-gcp</code>, y presiona el bot\u00f3n <code>Crear</code> (ver Figura #2): </li> </ul> <p> Figura # 2: Nombre al proyecto </p> <ul> <li>Una vez creado el proyecto, selecciona el proyecto desde las notificaciones o el men\u00fa desplegable (ver Figura #3): </li> </ul> <p> Figura # 3: Notificaci\u00f3n del proyecto </p>"},{"location":"despliegue_gcp/#paso-2-creacion-de-una-base-de-datos-en-cloud-sql","title":"Paso 2:  Creaci\u00f3n de una Base de Datos en Cloud SQL","text":"<ol> <li>Configuraci\u00f3n de la Instancia</li> </ol> <p>Desde el men\u00fa lateral de Google Cloud, selecciona la opci\u00f3n SQL para acceder a la secci\u00f3n de bases de datos (ver Figura #4): </p> <p> Figura # 4: Bases de Datos </p> <ul> <li>Haz clic en Crear Instancia con Cr\u00e9ditos Gratuitos para iniciar el proceso de creaci\u00f3n (ver Figura #5): </li> </ul> <p> Figura # 5: Crear Instancia </p> <ul> <li>Selecciona PostgreSQL como el motor de base de datos para la instancia (ver Figura #6): </li> </ul> <p> Figura # 6: Seleccionar PostgreSQL </p> <ul> <li>Configura los par\u00e1metros iniciales de la instancia:<ul> <li>Ajuste predeterminado de edici\u00f3n: Zona de pruebas.</li> <li>Versi\u00f3n de la base de datos: PostgreSQL 16.</li> <li>ID de la instancia: kotlinbase.</li> <li>Contrase\u00f1a: kotlinroot.</li> <li>Regi\u00f3n: Selecciona una cercana como us-central1.</li> <li>Disponibilidad zonal: Zona \u00fanica (ver Figura #7): </li> </ul> </li> </ul> <p> Figura # 7: Par\u00e1metros de la instancia </p> <ul> <li>Personaliza los recursos de la m\u00e1quina para optimizar costos. Selecciona la opci\u00f3n Con n\u00facleo compartido con 1 CPU virtual (ver Figura #8): </li> </ul> <p> Figura # 8: Personaliza Instancia </p> <ul> <li>Haz clic en Crear para finalizar la configuraci\u00f3n (ver Figura #9):. </li> </ul> <p> Figura # 9: Crear Instancia </p> <ul> <li>Crear una Base de Datos:</li> <li>Una vez creada la instancia, accede a la pesta\u00f1a Bases de Datos y haz clic en Crear Base de Datos. (Figura #10). </li> </ul> <p> Figura # 10: Base de Datos </p> <ul> <li>Asigna un nombre, como <code>kotlindb</code>. y presionar el boton Crear (Figura #11).  </li> </ul> <p> Figura # 11: Crear Base de Datos </p>"},{"location":"despliegue_gcp/#paso-3-configuracion-de-conexion-publica","title":"Paso 3: Configuraci\u00f3n de Conexi\u00f3n P\u00fablica","text":"<p>En este paso, configuraremos el acceso p\u00fablico para la base de datos PostgreSQL en Google Cloud SQL. Esto permitir\u00e1 conectar herramientas locales como DBeaver para verificar y gestionar los datos.</p> <ul> <li>Habilitar la Conexi\u00f3n P\u00fablica</li> <li>Accede a la instancia de la base de datos PostgreSQL en la consola de Google Cloud.</li> <li>Navega a la secci\u00f3n Conexiones en el men\u00fa lateral (Ver Figura #12). </li> </ul> <p> Figura # 12: Conexi\u00f3n </p> <ul> <li>En la pesta\u00f1a Redes, marca la opci\u00f3n IP P\u00fablica para habilitar conexiones externas.</li> <li> <p>Haz clic en Agregar una Red para configurar redes autorizadas.</p> </li> <li> <p>Configurar la Red Permitida</p> <ul> <li>En la ventana emergente, completa los siguientes campos (Ver Figura #13):<ul> <li>Nombre: Ingresa un nombre descriptivo, como <code>abierta</code>.</li> <li>Red: Introduce <code>0.0.0.0/0</code> para permitir conexiones desde cualquier direcci\u00f3n IP. </li> </ul> </li> </ul> </li> </ul> <p> Figura # 12: Agregar Red </p> <ul> <li>Haz clic en Guardar para aplicar los cambios.</li> </ul> <p>\u26a0\ufe0f Advertencia: Esta configuraci\u00f3n permite conexiones desde cualquier lugar y puede ser un riesgo de seguridad. Se recomienda usar esta configuraci\u00f3n solo en entornos de desarrollo.</p> <ul> <li>Probar la Conexi\u00f3n con DBeaver<ul> <li>Abre DBeaver (o cualquier cliente de base de datos).</li> <li>Crea una nueva conexi\u00f3n seleccionando PostgreSQL como tipo de base de datos.</li> <li>Completa los campos con los detalles obtenidos de la instancia:<ul> <li>Host: IP p\u00fablica de la instancia (disponible en la consola de Google Cloud).</li> <li>Puerto: <code>5432</code>.</li> <li>Usuario: <code>postgres</code>.</li> <li>Contrase\u00f1a: La configurada previamente (<code>kotlinroot</code> en este ejemplo).</li> </ul> </li> <li>Haz clic en Probar conexi\u00f3n para confirmar que todo funciona correctamente (Ver Figura #14).      <p> Figura # 14: Probar Conexi\u00f3n         </p></li> </ul> </li> </ul>"},{"location":"despliegue_gcp/#paso-4-instalacion-y-configuracion-del-sdk-de-google-cloud","title":"Paso 4: Instalaci\u00f3n y Configuraci\u00f3n del SDK de Google Cloud","text":"<p>Google Cloud SDK nos permitir\u00e1 desplegar la aplicaci\u00f3n desde la l\u00ednea de comandos.</p> <ul> <li> <p>Descargar e Instalar el SDK</p> <ul> <li>Ve a la p\u00e1gina oficial del SDK de Google Cloud.</li> <li>Descarga la versi\u00f3n para tu sistema operativo y sigue las instrucciones de instalaci\u00f3n.</li> <li>Ejecuta el comando <code>./google-cloud-sdk/bin/gcloud init</code> en tu terminal para configurar el SDK.<ul> <li>Acepta las configuraciones predeterminadas y selecciona el proyecto en el que trabajas (Ver Figura #15).  <p> Figura # 15: Condiguraci\u00f3n del SDK Google Cloud </p></li> </ul> </li> </ul> </li> <li> <p>Seleccionar el Proyecto</p> <ul> <li>Durante la configuraci\u00f3n del SDK, selecciona el proyecto en el que se cre\u00f3 la base de datos.</li> <li> <p>Confirma el proyecto elegido con el identificador correspondiente (Ver Figura #16).  <p> Figura # 16: Selecci\u00f3n del Proyecto     </p></p> </li> <li> <p>Sigue los pasos interactivos para autenticarte y vincular el proyecto <code>kotlingcp</code>.</p> </li> <li>Puedes listar la configuraci\u00f3n actual del proyecto con:     <pre><code>    ./google-cloud-sdk/bin/gcloud config list\n</code></pre></li> </ul> </li> </ul>"},{"location":"despliegue_gcp/#configuracion-del-archivo-applicationproperties-para-conectarse-a-la-base-de-datos","title":"Configuraci\u00f3n del archivo application.properties para conectarse a la base de datos","text":"<p>Antes de continuar, necesitamos ajustar las configuraciones para que nuestra aplicaci\u00f3n pueda comunicarse correctamente con la base de datos que creamos en Google Cloud. Esto implica agregar la IP p\u00fablica, el usuario y la contrase\u00f1a asignados a la base.</p>"},{"location":"despliegue_gcp/#modificacion-del-archivo-applicationproperties","title":"Modificaci\u00f3n del archivo application.properties","text":"<p>Abrimos el archivo application.properties y configuramos las siguientes propiedades:</p> <pre><code>spring.datasource.url=jdbc:postgresql://34.171.125.70:5432/kotlindb\nspring.datasource.username=postgres\nspring.datasource.password=kotlingcp\nspring.jpa.hibernate.ddl-auto=update\nspring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect\n</code></pre> <ul> <li><code>spring.datasource.url</code>: Especifica la URL de conexi\u00f3n, que incluye la IP p\u00fablica de la instancia, el puerto (5432), y el nombre de la base de datos (<code>kotlindb</code>).</li> <li><code>spring.datasource.username</code>: Usuario para conectarse a la base (<code>postgres</code>).</li> <li><code>spring.datasource.password</code>: Contrase\u00f1a para el usuario (<code>kotlingcp</code>).</li> </ul> <p>Si no recuerdas la IP p\u00fablica o la contrase\u00f1a, puedes consultar esta informaci\u00f3n desde el panel de Google Cloud SQL.</p>"},{"location":"despliegue_gcp/#probando-la-conexion","title":"Probando la conexi\u00f3n","text":"<p>Para verificar que todo est\u00e1 funcionando correctamente, ejecutamos el proyecto con el siguiente comando:</p> <pre><code>./gradlew bootRun\n</code></pre> <p>Esperamos a que compile y luego ingresamos en el navegador la URL correspondiente, por ejemplo: <code>http://localhost:8080/api/speakers</code>.</p> <p>Si la conexi\u00f3n a la base es exitosa, el resultado ser\u00e1 un JSON vac\u00edo, indicando que no hay usuarios registrados todav\u00eda. Esto confirma que la aplicaci\u00f3n est\u00e1 conectada a la base de datos, pero a\u00fan no hay registros.</p>"},{"location":"despliegue_gcp/#preparando-la-aplicacion-para-el-despliegue-en-google-cloud","title":"Preparando la aplicaci\u00f3n para el despliegue en Google Cloud","text":"<p>Antes de desplegar nuestra aplicaci\u00f3n, necesitamos realizar algunas configuraciones para garantizar que los archivos correctos sean enviados a Google Cloud. Esto es importante porque Google App Engine compila y ejecuta la aplicaci\u00f3n directamente en la nube, por lo que ciertos archivos locales no deben incluirse en el proceso de despliegue.</p>"},{"location":"despliegue_gcp/#creando-el-archivo-gcloudignore","title":"Creando el archivo .gcloudignore","text":"<p>Crea el archivo <code>.gcloudignore</code> para excluir carpetas y archivos innecesarios en el despliegue:</p> <pre><code>.gradle/\nbuild/\nout/\ngradlew\ngradlew.bat\n\ntarget/\n.git/\n.idea/\n*.iml\n.mvn/\nmvnw\nmvnw.cmd\n</code></pre>"},{"location":"despliegue_gcp/#creando-el-descriptor-appyaml","title":"Creando el descriptor app.yaml","text":"<p>Para que Google App Engine pueda desplegar correctamente nuestra aplicaci\u00f3n, es necesario crear un archivo de configuraci\u00f3n llamado app.yaml. Este archivo especifica las configuraciones b\u00e1sicas necesarias para el entorno de ejecuci\u00f3n.</p> <ul> <li> <p>Ubicaci\u00f3n del archivo:     Crea el archivo app.yaml en la ra\u00edz del proyecto.</p> </li> <li> <p>Contenido del archivo: Dentro de este archivo, agrega las siguientes l\u00edneas:</p> </li> </ul> <pre><code>runtime: java21\ninstance_class: F2\n</code></pre> <ul> <li><code>runtime</code>: Especifica el entorno para aplicaciones Java.</li> <li> <p><code>instance_class</code>: Define el tipo de instancia. Google clasifica las instancias seg\u00fan su capacidad:</p> <ul> <li><code>F1</code>: Instancia b\u00e1sica (por defecto).</li> <li><code>F2</code>: Instancia con m\u00e1s recursos, recomendada para aplicaciones como Kotlin, que requieren mayor capacidad de procesamiento.</li> </ul> </li> <li> <p>Ejecutar el Despliegue: </p> <ul> <li>Para desplegar la aplicaci\u00f3n en <code>App Engine</code>, usa el siguiente comando:     <pre><code>    gcloud app deploy\n</code></pre></li> <li>Selecciona la regi\u00f3n m\u00e1s cercana a tu ubicaci\u00f3n (como <code>us-central1</code> para Am\u00e9rica Central) si es tu primer despliegue. Una vez completado, obtendr\u00e1s una URL similar a:     <pre><code>    https://famous-cursor-442219-q6.rj.r.appspot.com\n</code></pre></li> <li>Verificaci\u00f3n: Accede a la URL y aseg\u00farate de que la aplicaci\u00f3n est\u00e9 funcionando correctamente. Por ejemplo, verifica los endpoints <code>api/speakers</code>.</li> </ul> </li> </ul>"},{"location":"despliegue_gcp/#paso-5-habilitar-la-api-de-cloud-sql-admin","title":"Paso 5: Habilitar la API de Cloud SQL Admin","text":"<ul> <li> <p>Mejorar la Seguridad de la Aplicaci\u00f3n Despu\u00e9s del despliegue inicial, es importante fortalecer la seguridad.</p> </li> <li> <p>Eliminar la IP P\u00fablica</p> <ul> <li>Ve a la consola de Google Cloud SQL.</li> <li>En la secci\u00f3n Conexiones &gt; Redes, elimina la red p\u00fablica <code>0.0.0.0/0</code>.</li> <li>Esto impedir\u00e1 el acceso desde cualquier IP p\u00fablica. (Ver Figura #17)  <p> Figura # 17: Eliminar IP Publica     </p></li> </ul> </li> </ul> <p>Para realizar una conexi\u00f3n segura con la base de datos, habilitaremos la API Cloud SQL Admin, que permite gestionar instancias de bases de datos desde aplicaciones desplegadas en Google Cloud.</p> <ul> <li>Activar la API<ul> <li>En la consola de Google Cloud, busca Cloud SQL Admin API en el buscador de la parte superior.</li> <li>Haz clic en Habilitar para activar la API (Ver Figura #17).</li> </ul> </li> </ul> <p> <p> Figura # 17: Activar API         </p></p> <p>Esto permitir\u00e1 a las cuentas de servicio de Google gestionar conexiones a la base de datos de manera segura.</p>"},{"location":"despliegue_gcp/#paso-6-configuracion-de-dependencias-en-el-proyecto-kotlin","title":"Paso 6: Configuraci\u00f3n de Dependencias en el Proyecto Kotlin","text":"<p>En este paso, ajustaremos las dependencias necesarias para conectar nuestra aplicaci\u00f3n a Cloud SQL. En lugar de usar la IP p\u00fablica, configura la conexi\u00f3n usando cadenas seguras proporcionadas por Google.</p> <ul> <li>Agregar la Dependencia de PostgreSQL<ul> <li>Abre el archivo <code>pom.xml</code> de tu proyecto.</li> <li>Agrega la dependencia correspondiente para usar PostgreSQL con Google Cloud:</li> </ul> </li> </ul> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.google.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-gcp-starter-sql-postgresql&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Si usas <code>Gradle</code>, agrega lo siguiente en tu archivo <code>build.gradle</code>:</p> <pre><code>implementation(\"com.google.cloud:spring-cloud-gcp-starter-sql-postgresql\")\n</code></pre> <p>(Ver Figura #18)  <p> Figura # 18: Adicionar Dependencia         </p></p> <ul> <li>Configurar la Cadena de Conexi\u00f3n Modifica las propiedades de conexi\u00f3n de la base de datos. En lugar de una URL con IP, usa la configuraci\u00f3n proporcionada por Google:<ul> <li>Accede a las propiedades de tu aplicaci\u00f3n (<code>application.properties</code> o <code>application.yml</code>).</li> <li>Configura los valores de conexi\u00f3n utilizando el nombre de la conexi\u00f3n (disponible en la consola de Google Cloud en la instancia de PostgreSQL) (Ver Figura #19):</li> </ul> </li> </ul> <pre><code># Configuraci\u00f3n de conexi\u00f3n segura\nspring.cloud.gcp.sql.database-name=kotlindb\nspring.cloud.gcp.sql.instance-connection-name=famous-cursor-442219-q6:us-central1:kotlinbase\nspring.datasource.username=postgres\nspring.datasource.password=kotlinroot\n</code></pre> <p>Nota: Comenta cualquier configuraci\u00f3n previa de URL para evitar conflictos:</p> <pre><code># spring.datasource.url=jdbc:postgresql://&lt;IP_PUBLICA&gt;:5432/kotlindb\n</code></pre> <p> <p> Figura # 19: Conexi\u00f3n Cloud SQL         </p></p>"},{"location":"despliegue_gcp/#desplegar-y-verificar-la-conexion","title":"Desplegar y verificar la conexi\u00f3n","text":"<p>Ahora podemos proceder con el despliegue y probar que la aplicaci\u00f3n tiene conexi\u00f3n con la base de datos.</p> <ul> <li>Despliegue: Ejecuta el siguiente comando en tu terminal:</li> </ul> <pre><code>gcloud app deploy\n</code></pre> <ul> <li> <p>Esperar el proceso: Deja que Google App Engine complete el despliegue. Este proceso puede tardar unos minutos.</p> </li> <li> <p>Obtener la URL: Una vez finalizado, Google proporcionar\u00e1 una URL p\u00fablica para tu aplicaci\u00f3n.</p> </li> <li> <p>Verificaci\u00f3n: Accede a la URL proporcionada y dir\u00edgete al endpoint /speakers. Por ejemplo:</p> </li> </ul> <pre><code>https://&lt;tu-app-id&gt;.appspot.com/speakers\n</code></pre> <p>Si todo est\u00e1 configurado correctamente, la aplicaci\u00f3n deber\u00eda mostrar datos o confirmar la conexi\u00f3n con la base de datos.</p>"},{"location":"despliegue_gcp/#paso-7-configuracion-iam-y-despliegue","title":"Paso 7: Configuraci\u00f3n IAM y Despliegue","text":"<p>Aseg\u00farate de que la cuenta de servicio predeterminada de App Engine tenga los roles necesarios para gestionar Cloud SQL:</p> <ul> <li> <p>Configurar Credenciales Locales</p> <ul> <li> <p>Una vez que la aplicaci\u00f3n est\u00e1 funcionando, podemos verificar su estado en la consola de administraci\u00f3n de Google Cloud. Ah\u00ed veremos que existen varias cuentas creadas autom\u00e1ticamente. Una de estas cuentas es la predeterminada de App Engine, la cual tiene permisos necesarios para realizar diversas operaciones dentro de Google Cloud, siempre que se le hayan asignado los privilegios adecuados.</p> </li> <li> <p>Sin embargo, en el entorno local, no contamos con esa cuenta predeterminada o \"aplicativa\". Aunque tu cuenta personal puede haber creado el proyecto, esto no implica que autom\u00e1ticamente tenga los permisos necesarios para realizar ciertas operaciones desde tu entorno local.</p> </li> <li> <p>Para solucionar esto, es necesario configurar las credenciales en tu entorno local. Esto se hace mediante el siguiente comando:    </p> </li> <li> <p>Usa el siguiente comando para autenticar tu m\u00e1quina local con las credenciales de Google Cloud: <pre><code>gcloud auth application-default login\n</code></pre></p> </li> <li> <p>Esto abrir\u00e1 el navegador para seleccionar tu cuenta de Google Cloud.</p> </li> </ul> </li> <li> <p>Revisar Cuentas de Servicio</p> <ul> <li>Verifica que la cuenta de servicio predeterminada de <code>App Engine</code> tenga permisos de acceso a Cloud SQL (Ver Figura #20).</li> </ul> </li> </ul> <p> <p> Figura # 20: IAM         </p></p> <ul> <li>Probar la Aplicaci\u00f3n Localmente Corre la aplicaci\u00f3n localmente y verifica que se conecte correctamente a la base de datos:</li> </ul> <pre><code>./gradlew bootRun\n</code></pre> <p>Aseg\u00farate de que el endpoint <code>/spearkes</code> funcione como se espera.</p>"},{"location":"despliegue_gcp/#proyecto-final","title":"Proyecto Final","text":"<p>El proyecto completo desarrollado durante este workshop est\u00e1 disponible en el siguiente repositorio de GitHub:</p> <p>\ud83d\udd17 Proyecto Final: kotlin-gcp</p> <p>En este repositorio encontrar\u00e1s todo el c\u00f3digo fuente, configuraciones, y las instrucciones necesarias para ejecutar el proyecto tanto localmente como en Google Cloud.</p>"},{"location":"despliegue_gcp/#sigueme-en-redes-sociales","title":"S\u00edgueme en Redes Sociales","text":"<p>Si disfrutaste este workshop, \u00a1aseg\u00farate de seguirme para m\u00e1s contenido sobre Kotlin, Spring Boot y desarrollo en la nube!</p> <ul> <li>Web: Geovanny Mendoza</li> <li>GitHub: @geovannymcode</li> <li>Twitter: @geovannycode</li> <li>LinkedIn: Geovanny Mendoza</li> <li>YouTube: Geovanny Mendoza</li> </ul>"},{"location":"despliegue_gcp/#resumen-del-workshop","title":"Resumen del Workshop","text":"<p>En este workshop aprendimos a desplegar una API REST desarrollada en Kotlin y Spring Boot en Google Cloud. Estos son los pasos principales que seguimos:</p> <ul> <li> <p>Fase 1: Configuraci\u00f3n Inicial</p> <ul> <li>Uso de Spring Initializr para generar un proyecto base.</li> <li>Configuraci\u00f3n de dependencias clave como Spring Web y JPA.</li> <li>Creaci\u00f3n de la estructura del proyecto.</li> </ul> </li> <li> <p>Fase 2: Construcci\u00f3n de la API REST</p> <ul> <li>Implementaci\u00f3n de entidades, repositorios, servicios y controladores.</li> <li>Uso de Flyway para la gesti\u00f3n de migraciones en la base de datos.</li> </ul> </li> <li> <p>Fase 3: Configuraci\u00f3n de PostgreSQL en Cloud SQL</p> <ul> <li>Creaci\u00f3n de una instancia PostgreSQL en Google Cloud.</li> <li>Configuraci\u00f3n de conexiones seguras y prueba local con DBeaver.</li> </ul> </li> <li> <p>Fase 4: Ejecuci\u00f3n Local</p> <ul> <li>Validaci\u00f3n de endpoints usando Postman.</li> <li>Inserci\u00f3n y recuperaci\u00f3n de datos en la base de datos.</li> </ul> </li> <li> <p>Fase 5: Preparaci\u00f3n del Despliegue</p> <ul> <li>Creaci\u00f3n de los archivos .gcloudignore y app.yaml para App Engine.</li> <li>Configuraci\u00f3n de Maven/Gradle para empaquetado de la aplicaci\u00f3n.</li> </ul> </li> <li> <p>Fase 6: Despliegue en App Engine</p> <ul> <li>Uso del comando gcloud app deploy para subir la aplicaci\u00f3n.</li> <li>Verificaci\u00f3n de que la API REST funciona en la URL proporcionada por Google Cloud.</li> </ul> </li> <li> <p>Fase 7: Seguridad y Mejores Pr\u00e1cticas</p> <ul> <li>Eliminaci\u00f3n de la IP p\u00fablica para proteger la base de datos.</li> <li>Habilitaci\u00f3n de Cloud SQL Admin API y configuraci\u00f3n de cadenas seguras.</li> <li>Uso de Spring Cloud GCP para integraciones nativas con Google Cloud.</li> </ul> </li> <li> <p>Fase 8: Validaci\u00f3n y Optimizaci\u00f3n</p> <ul> <li>Configuraci\u00f3n de credenciales locales para desarrollo seguro.</li> <li>Validaci\u00f3n del funcionamiento de la API en producci\u00f3n y local.</li> </ul> </li> </ul>"},{"location":"despliegue_gcp/#resultado-final","title":"Resultado Final","text":"<p>Tras completar este workshop, tendr\u00e1s una aplicaci\u00f3n Kotlin desplegada en la nube, conectada a una base de datos segura, con las mejores pr\u00e1cticas implementadas para garantizar rendimiento y escalabilidad.</p> <p>\u00a1Gracias por participar en este workshop! Si tienes dudas o necesitas m\u00e1s ayuda, no dudes en contactarme o dejar tus comentarios en mis redes sociales. \ud83c\udf89</p>"},{"location":"referencias/","title":"Referencias","text":"<p>Descaraga de Google Cloud SDK</p> <p>Documentaci\u00f3n Spring GCP</p> <p>Documentaci\u00f3n Spring GCP SQL PostgreSQL</p> <p>Google Cloud GCP</p> <p>App Engine</p>"}]}